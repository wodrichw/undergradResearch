import sys

# USAGE: python findExclusions.py 3
# generates an exclusion tree of height 3, you can put in other numbers than 3

# This program has two major functions: buildTree and findExclusionChildren.
# buildTree takes a node and recursively builds the two children of that node.
# The data that buildTree puts into each node is generated by findExclusionChildren.

# findExclusionChildren takes a list of exclusions and finds two new exclusions that
# is larger than all exclusions in the given list. The new exclusions are of the form
# 0p0 and 1p1 where p is a pallendrom. findExclusionChildren is a dynamic
# program that has several assumptions that makes it hard to follow.
# These assumptions are surrounding how the validity of a pallendrome is checked.
# Firstly, only the right half of the pallendrome is checked. This is because the 
# exclusions are pallendromes and hence symmetrical. Hence, checking the right side of
# a pallendrome infers the validity of the left side. The second assumption is that
# only the rightmost of pallendrome needs to be checked. This is because all smaller
# sub pallendromes have already been checked in previous iterations.

# The level order tree traversal sequentially prints all nodes at the same depth




class Node:
    def __init__(self, parent = None, exclusion = None, left = None, right = None):
        self.parent = parent
        self.left = left
        self.right = right
        self.exclusion = exclusion
    


def findExclusionChildren(E):
    # P is a FIFO que
    P = ["", "0", "1"]
    children = []
    while children == []:
        for i in range(len(P)):
            # pop the SMALLEST element of p
            p = P.pop(0)

            valid0P0 = True
            valid1P1 = True
            
            #test 0p0 and 1p1 with all exclusions smaller than 0p0 and 1p1
            for e in [e for e in E if len(e) <= len(p) + 2]:
                #check the RIGHT of 0p0 and see if equal to e
                if ("0"+p+"0")[-len(e):] == e:
                    valid0P0 = False
                #check the RIGHT of 1p1 and see if equal to e
                if ("1"+p+"1")[-len(e):] == e:
                    valid1P1 = False
            
            # if 0p0 and 1p1 both don't contain an exclusion, they are the children
            # otherwise, add 0p0 and 1p1 to the END of the P FIFO que
            if valid0P0 and valid1P1 and len(E[0]) < len(p) + 2:
                children = ["0"+p+"0", "1"+p+"1"]
                break
            if valid0P0:
                P += ["0"+p+"0"]
            if valid1P1:
                P += ["1"+p+"1"]
    return children

def buildTree(n, currentDepth, maxDepth):
    def getExclusions(n):
        if n == None: return []
        return [n.exclusion] + getExclusions(n.parent)

    if currentDepth == maxDepth:
        return None
    E = getExclusions(n)
    c1, c2 = findExclusionChildren(E)
    n.left = buildTree(Node(n, c1), currentDepth + 1, maxDepth)
    n.right = buildTree(Node(n, c2), currentDepth + 1, maxDepth)
    return n

# taken from https://www.geeksforgeeks.org/level-order-tree-traversal/
def printLevelOrder(root): 
    # Base Case 
    if root is None: 
        return
    # Create an empty queue for level order traversal 
    queue = [] 
    # Enqueue Root and initialize height 
    queue.append(root) 
    while(len(queue) > 0): 
        # Print front of queue and remove it from queue 
        print(queue[0].exclusion) 
        node = queue.pop(0)
        #Enqueue left child 
        if node.left is not None: 
            queue.append(node.left) 
        # Enqueue right child 
        if node.right is not None: 
            queue.append(node.right)

# excTree = buildTree(Node(exclusion='11'), 0, int(sys.argv[1]))
excTree = buildTree(Node(exclusion='11'), 0, 3)
printLevelOrder(excTree)
        

